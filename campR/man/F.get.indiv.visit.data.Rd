% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_indiv_visit_data.r
\name{F.get.indiv.visit.data}
\alias{F.get.indiv.visit.data}
\title{F.get.indiv.visit.data}
\usage{
F.get.indiv.visit.data(site, run, min.date, max.date)
}
\arguments{
\item{site}{<describe argument>}

\item{run}{<describe argument>}

\item{min.date}{<describe argument>}

\item{max.date}{<describe argument>}
}
\value{
<describe return value>
}
\description{
Fetch the visit data for a particular site and run from an Access data base. The resulting data
   set should have one line for each visit to a trap at the site. .

   input:
   db = full path and name of the Access data base to retrieve data from
   tables = vector with named components containing names
           of the table in db to pull values from
   site = site ID of place we want to do estimates for.  Remember, site encompases multiple traps.   Individual screw 
           traps are subsites.  Project could be multiple sites.
   run = the single run ID of the fish we want.  If run = NA, all records  will be pulled.

       YOU DO NOT ACTUALLY NEED RUN HERE.  IT MAKES NO DIFFERENCE, TAKE THIS OUT OF PARAMETERS TO THIS CALL.

   min.date and max.date = minimum and maximum dates for data to be included. Format = "YYYY-MM-DD"


   This routine is very similar to get_catch_data, except that it does not average over subsites.
   Raw catches are returned.

   Here is the way to interpret visitTime and visitTime2
    "visit start" field (named "visitTime")
    for visitTypeID = 1 Date/time of arrival at trap
    for visitTypeID = 2 Date/time the trap was emptied
    for visitTypeID = 3 Date/time the trap was emptied
    for visitTypeID = 4 Date/time the trap was emptied
    for visitTypeID = 5 Date/time of arrival at trap
    for visitTypeID = 6 Date/time of arrival at trap


    "visit end" field (named "visitTime2")
    for visitTypeID = 1 Date/time the trap began fishing
    for visitTypeID = 2 Date/time the trap began fishing
    for visitTypeID = 3 Date/time the trap began fishing
    for visitTypeID = 4 Date/time of the end of the visit
    for visitTypeID = 5 Date/time of the end of the visit
    for visitTypeID = 6 Date/time of the end of the visit 




   *******
   First, put the start and stop dates of the run into a list
   Need these to filter visits.
}
\details{
<other comments found in file>
   *******
   Retreive site info to get common names.  
   *******
   Visits SQL
   Make variable vectors one long string for sql statement

   THIS IS MIKE'S TEMPLATE QUERY FOR TRAP VISITS
SELECT Site.siteName AS TrappingSite
, SubSite.subSiteName AS TrapPosition
, ProjectDescription.projectName AS Project
, TrapVisit.projectDescriptionID
, TrapVisit.trapVisitID
, TrapVisit.dataSheetNumber AS TrapVisitDataSheetNumber
, TrapVisit.visitTime AS VisitTime1
, TrapVisit.visitTime2 AS VisitTime2
, luVisitType.visitType AS VisitType
, luFishProcessed.fishProcessed AS FishProcessed
, luSampleGear.sampleGear
, luNoYes.noYes AS TrapInThalweg
, luTrapFunctioning.trapFunctioning AS TrapFunction
, TrapVisit.coneDepthAtStart AS ConeDepthAtStart
, TrapVisit.coneDepthAtEnd AS ConeDepthAtEnd
, luNoYes_1.noYes AS HalfCone
, luNoYes_2.noYes AS IncludeCatchInAnalyses
, TrapVisit.includeCatchComments AS IncludeCatchComments
, luDebrisVolumeCat.debrisVolumeCat AS DebrisVolumeCategory
, TrapVisit.debrisVolume AS DebrisVolumeMeasure
, TrapVisit.debrisVolumeUnits
, TrapVisit.debrisType AS DebrisType
, TrapVisit.comments AS Comments
, luNoYes_3.noYes AS DataCollected
FROM 
    (Site INNER JOIN SubSite ON Site.siteID = SubSite.siteID) 
    INNER JOIN (ProjectDescription 
        INNER JOIN (luVisitType 
            RIGHT JOIN (luTrapFunctioning 
                RIGHT JOIN (luSampleGear 
                    RIGHT JOIN (luNoYes 
                        RIGHT JOIN (luFishProcessed 
                            RIGHT JOIN (luDebrisVolumeCat 
                                RIGHT JOIN (luNoYes AS luNoYes_3 
                                    RIGHT JOIN (luNoYes AS luNoYes_2 
                                        RIGHT JOIN (luNoYes AS luNoYes_1 
                                            RIGHT JOIN TrapVisit 
    ON luNoYes_1.noYesID = TrapVisit.halfConeID) 
    ON luNoYes_2.noYesID = TrapVisit.includeCatchID) 
    ON luNoYes_3.noYesID = TrapVisit.dataCollectedID) 
    ON luDebrisVolumeCat.debrisVolumeCatID = TrapVisit.debrisVolumeCatID) 
    ON luFishProcessed.fishProcessedID = TrapVisit.fishProcessedID) 
    ON luNoYes.noYesID = TrapVisit.inThalwegID) 
    ON luSampleGear.sampleGearID = TrapVisit.sampleGearID) 
    ON luTrapFunctioning.trapFunctioningID = TrapVisit.trapFunctioningID) 
    ON luVisitType.visitTypeID = TrapVisit.visitTypeID) 
    ON ProjectDescription.projectDescriptionID = TrapVisit.projectDescriptionID) 
    ON SubSite.subSiteID = TrapVisit.trapPositionID
ORDER BY Site.siteName, SubSite.subSiteName, TrapVisit.visitTime, TrapVisit.visitTime2;

   Note: query pulls visits from 7 days prior to start of run in order to compute sampleStart and sampleEnd. Must delete these records later.
   No visits found, exit nicely.
   This query pulls the trap re-starts
   Append restarts to end of visits.  Times will be sorted in assign_sample_period.r
   Make sure time zones are Pacific. In case analysis is run in another time zone.
   Assign sample period start and stop
   Get rid of missing sampleEnd's.  sampleEnd's are missing for lines when trap restarted.  
   Get rid of missing sampleStarts's.  This is an error.  Happens when trap stopped (visitType=4), but then next record trap is running (visitType=2 or 3) without an intervening trap start (visitType=1)
warning("Trap stopped, but no trap start record.  See LOG.")
   Drop them, this will create a gap, that will later be imputed.
   Assign batch date if missing
   Delete the "extra" records outside the run period
   Assign gap lengths
   Find subsiteID names
   Fetch subsite names
   Store values as attribute for convienance.
}
\examples{
\dontrun{
<insert examples>

}
}
\author{
WEST Inc.
}
\seealso{
\code{\link{<related routine>}}, \code{\link{<related routine>}}
}

