% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_catch_data.r
\name{F.get.catch.data}
\alias{F.get.catch.data}
\title{F.get.catch.data}
\usage{
F.get.catch.data(site, taxon, min.date, max.date, autoLS = FALSE,
  nLS = NULL, weightUse = NULL)
}
\arguments{
\item{site}{<describe argument>}

\item{taxon}{<describe argument>}

\item{min.date}{<describe argument>}

\item{max.date}{<describe argument>}

\item{autoLS=FALSE}{<describe argument>}

\item{nLS=NULL}{<describe argument>}

\item{weightUse=NULL}{<describe argument>}
}
\value{
<describe return value>
}
\description{
Fetch the catch data for a SINGLE TAXON from an Access data base. Do some initial
   computations, like dates.

   input:
   db = full path and name of the Access data base to retrieve data from
   tables = vector with named components containing names
           of the table in db to pull values from
   site = site ID of place we want to do estimates for.
   taxon = the taxon number(s) (from luTaxon) to retrieve.  If a scalar, only
       one taxon is retrieved.  If vector of taxon id's, the sum of all
       taxons is retrieved.
   run = the single run ID of the fish we want.  If run = NA, all records for the fish
       will be pulled.
   min.date = minimum date for data to include. This is a text string in the format %Y-%m-%d, or YYYY-MM-DD
   max.date = maximum date for data to include.  Same format as min.date
   autoLS = FALSE, nothing new is done. autoLS =TRUE the life stage is assigned using a mixture distribution/clustering analysis
   nLS = NULL, ignored if autoLS is false, specify the number of groups to be fit
   useWeight = NULL, ignored if autoLS is false, NULL = program decides if to use weight, FALSE = weight is not used for assigning lifestage

   To be included in the catch data, a record has to be from the site,
   of the correct taxon, of the correct run, and between min and max dates.
}
\details{
<other comments found in file>
   Open ODBC channel
   *****
   This SQL file develops the hours fished and TempSamplingSummary table
   *****
   This SQL generates times when the traps were not fishing
   *****
   This SQL generates unmarked fish by run and life stage
   *****
   Now, fetch the result
 add 3/8/2016 -- look for long gaps.
 SQL code to find the gaps, and modify trapPositionIDs accordingly.
 get the updated results
 no long gaps to worry about.  so just keep going with the version of catch that we already
 pulled in from the mdb.
   ******************************************************************
   Assign time zone (probably does not matter)
  jason add all this get includeCatchID:  Assign time zone (definitely does matter -- otherwise it goes to MST)
 includecatchID$StartTime <- includecatchID$timeSampleStarted
 attr(includecatchID$StartTime, "tzone") <- time.zone
 sampleGearID ProjID trapPositionID trapVisitID
   ********************************************************************
   At this point, catch has all visits in it, even if no fish were caught.
   It also has non-fishing intervals.  This is how you identify these intervals:
       1. zero catch = catch$Unmarked == 0  ($FinalRun and $LifeStage are both "Unassigned" for these lines)
       2. not fishing = catch$TrapStatus == "Not fishing"  (equivalently, $trapVisitID is missing for these lines.  Only time its missing.)

   Pull apart the visits from the catch, because plus count expansion only applys to positive catches.
   Recall, catch currently has multiple lines per trapVisit delineating fish with different fork lengths.
   ********************************************************************
   Subset the catches to just positives.  Toss the 0 catches and non-fishing visits.

 Jared's Addition
 this is where the life stage assignment will happen from a function call
write.csv(catch,paste0(output.file,site,'.csv'),row.names=FALSE)
 for debugging
return(catch)
stop('That is good enough')

 get summary counts of catch run vs. lifetstage for internal checking.
 jason adds the if here 1/12/2016, since for some reports, we could have 0 valid catch, but non-zero invalid catch.
 aggregate doesn't work on zero rows, thus requiring the if-clause.
   ********************************************************************
 expand half-cone operations to full-cone.  this needs to happen prior to plus-counting.
   Expand the Plus counts
 deal with awkwardness of doing the plus-count routine two times with slightly different data (due to plus-counting)
                                    ,after 'times2' - before 'times2'
                                    , should be zero
   look <- test[,c('trapVisitID','FinalRun','lifeStage','forkLength','RandomSelection','Unassd','trapPositionID','SampleDate','TrapStatus','TrapPosition','halfConeID','Unmarked','preUnmarked','halfConeAssignedCatch','halfConeUnassignedCatch','assignedCatch','unassignedCatch')]
   look[as.Date(look$SampleDate) == '2014-02-28' & look$TrapPosition == 'Gate 8',]
 data query where all are full catch -- just set the fancy variables to zero.
   Reassign factor levels because they may have changed.  I.e., we may have eliminated "Unassigned"
catch$lifeStage <- as.character( catch$Unassd ) jason - possibly delete
   ********************************************************************
   Assign batch dates -- jason adds the ifs 1/16/2016 to allow zero row visits and catch dfs to pass through
   Assign attributes
attr(catch, "site.abbr") <- catch$siteAbbreviation[1]
attr(catch, "runID") <- run
attr(catch, "run.name") <- run.name
attr(catch, "run.season") <- run.season
attr(catch, "site.stream") <- site.stream
attr(catch, "taxonID" ) <- taxon.string
attr(catch, "species.name") <- sp.commonName

f.banner("F.get.catch.data - Complete")
   Return two data frames. One containing positive catches.  The other containing visit and fishing information.
}
\examples{
<insert examples>

}
\author{
WEST Inc.
}
\seealso{
\code{\link{<related routine>}}, \code{\link{<related routine>}}
}

