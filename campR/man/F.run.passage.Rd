% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/run_passage.r
\name{F.run.passage}
\alias{F.run.passage}
\title{F.run.passage}
\usage{
F.run.passage(site, taxon, min.date, max.date, by, output.file, ci = TRUE)
}
\arguments{
\item{site}{<describe argument>}

\item{taxon}{<describe argument>}

\item{min.date}{<describe argument>}

\item{max.date}{<describe argument>}

\item{by}{<describe argument>}

\item{output.file}{<describe argument>}

\item{ci=TRUE}{<describe argument>}
}
\value{
<describe return value>
}
\description{
ANNUAL PRODUCTION ESTIMATES BY LIFE STAGE AND RUN ? TABULAR SUMMARY
   A table of passage estimates, with lifestages down the rows, and runs across the columns.

   Input:
   site = site ID of the place we want, trap locaton
   taxon = taxon number (from luTaxon) to retrieve


   ********
   Check that times are less than 1 year apart
}
\details{
<other comments found in file>
   ---- Start a progress bar
   ---- Fetch efficiency data
   ---- Fetch the catch and visit data
   Debugging
    tmp.catch0 <<- catch.df
    tmp.visit0 <<- visit.df
    print( table(catch.df$TrapStatus))
   ---- Summarize catch data by trapVisitID X FinalRun X lifeStage. Upon return, catch.df has one line per combination of these variables
catch.df <- F.summarize.fish.visit( catch.df )       jason turns off 4/15/2015
catch.df3 <- F.summarize.fish.visit( catch.df, 'halfcone' )     # jason - 1/14/2016 - we summarize over halfCone.  need to get these down to unique finalrun + lifestage + batchDate + trap
                   - the only reason we do this again is to get a different n.tot.
   Debugging
    tmp.catch <<- catch.df
    print( table(catch.df$TrapStatus))
    cat("in lifestage_passage.r (hit return) ")
    readline()
   ---- Compute the unique runs we need to do
   ---- Compute the unique life stages we need to do
   lstages <- unique(c(catch.df1$lifeStage,catch.df2$lifeStage))   # get all instances over the two df.  jason change 4/17/2015 5/21/2015: don't think we need to worry about catch.df0.
   lstages <- lstages[ !is.na(lstages) ]   #   Don't need this,  I am pretty sure lifeStage is never missing here.
   cat("\nLife stages found between", min.date, "and", max.date, ":\n")
   print(lstages)
   ---- Print the number of non-fishing periods
   ---- Extract the unique trap visits.  This will be used in merge to get 0's later
    ind <- !duplicated( catch.df$trapVisitID ) & !is.na(catch.df$trapVisitID)
    visit.df <- catch.df[ind, ]
    visit.df <- visit.df[, !(names(visit.df) %in% c("FinalRun", "lifeStage", "n.tot", "mean.fl", "sd.fl"))]
   ********
   Loop over runs
 jason puts together the catches based on total, unassigned, assigned.
 jason adds 6/7/2015 to throw out unassd counts from different runs that were creeping in.
 jason brings halfcone counts along for the ride 1/14/2016 -- only for run_passage, and not run lifestage?
theSumsBefore <<- accounting(catch.df,"byRun")
   ---- If we caught this run, compute passage estimate.
 old - catch.df.ls <- catch.df[ indRun & indLS, c("trapVisitID", "FinalRun", "lifeStage", 'n.Orig','mean.fl.Orig','sd.fl.Orig',"n.tot", "mean.fl", "sd.fl","n.Unassd")]
   ---- Merge in the visits to get zeros
   ---- Update the constant variables.  Missing n.tot when trap was fishing should be 0.
   ---- Add back in the missing trapVisitID rows.  These identify the gaps in fishing
catch.df.ls <- rbind( catch.df.ls, catch.df[ is.na(catch.df$trapVisitID), ] )
   ---- Update progress bar
   Debugging
                tmp.c <<- catch.df.ls
                tmp.r <<- release.df
   Debugging
                print(dim(visit.df))
                print(dim(catch.df.ls))
                print( table( tmp.c$FinalRun, useNA="always" ))
                print( table( tmp.c$lifeStage, useNA="always" ))
                print( table( tmp.c$trapVisitID, useNA="always" ))
                cat("in lifestage_passage (hit return) ")
                readline()
 jason add 2/25/2016 -- deal with traps with all zero fish.
 see if we have non-zero fish for a trap, given the lifestage and run.
   ---- Compute passage
       if(pass$nForkLenMM[1] != sum(totalRunXLifeStage[totalRunXLifeStage$FinalRun == run.name & (totalRunXLifeStage$LifeStage != "Unassigned" & totalRunXLifeStage$FinalRun != "Unassigned"),]$x)){
         stop('Issue with the accounting of all run-specific fish.  Investigate estimation of passage.')
       } else {
         cat('No issue with the accounting of all run-specific fish.  Continuing...\n')
       }
   ---- Update progress bar
print(pass)
   ---- Save
   ---- Write passage table to a file, if called for
   Fix up the pass table to pretty the output
 jason add.
 can't figure out how to join on posix dates.  so cheating.
 possibly obsolete, 12/14/2015
           tmp.df$date.alone <- as.Date(strptime(tmp.df$date,format="%F"))
           the.dates$date.alone <- as.Date(strptime(the.dates$uniqueDate,format="%F"))    # jason: from strftime to strptime. why the change?
           tmp.df <- merge(tmp.df,the.dates,by = c("date.alone"),all.x=TRUE)

           tmp.df$week <- paste0(strftime(tmp.df$date,"%Y"),"-",tmp.df$julianWeek,": ",tmp.df$julianWeekLabel)    #paste0(myYear,'-',tmp.jday %/% 7 + 1)
           tmp.df <- subset(tmp.df, select = -c(date.alone,uniqueDate,julianWeek,julianWeekLabel) )
   Merge in the trapsOperating column
   For aesthetics, change number fish measured on days in gaps from NA to 0
   Open file and write out header.
   Write out the table
 task 2.4, 1/8/2016:  if passage = 0, force propImputedCatch to be zero.
   ---- Plot the final passage estimates
   ---- compute percentages of each life stage
   ---- Write out the table
   We have more than one run
   ---- Append totals to bottom
 Produce pie or bar charts
     fl <- F.plot.lifestages( df, output.file, plot.pies=F )
     if( fl == "ZEROS" ){
       cat("FAILURE - F.lifestage.passage - ALL ZEROS\nCheck dates and finalRunId's\n")
       cat(paste("Working directory:", getwd(), "\n"))
       cat(paste("R data frames saved in file:", "<none>", "\n\n"))
       nf <- length(out.fn.roots)
       cat(paste("Number of files created in working directory = ", nf, "\n"))
       for(i in 1:length(out.fn.roots)){
         cat(paste(out.fn.roots[i], "\n", sep=""))
       }
       cat("\n")
       return(0)

     } else {
       out.fn.roots <- c(out.fn.roots, fl)
     }
fl <- F.plot.runs( df, output.file, plot.pies=F )
out.fn.roots <- c(out.fn.roots, fl)
   ---- Write out message
}
\examples{
<insert examples>

}
\author{
WEST Inc.
}
\seealso{
\code{\link{<related routine>}}, \code{\link{<related routine>}}
}

