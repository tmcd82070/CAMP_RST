#   ********
#   Loop over runs
ans <- lci <- uci <- matrix(0, length(lstages), length(runs))
dimnames(ans)<-list(lstages, runs)
out.fn.roots <- NULL
for( j in 1:length(runs) ){
run.name <<- runs[j]
# jason puts together the catches based on total, unassigned, assigned.
assd <- catch.df2[catch.df2$Unassd != 'Unassigned' & catch.df2$FinalRun == run.name,c('trapVisitID','lifeStage','n.tot','mean.fl','sd.fl')]
colnames(assd) <- c('trapVisitID','lifeStage','n.Orig','mean.fl.Orig','sd.fl.Orig')
catch.dfA <- merge(catch.df1,assd,by=c('trapVisitID','lifeStage'),all.x=TRUE)
unassd <- catch.df0[catch.df0$FinalRun == run.name,c('trapVisitID','lifeStage','n.tot')]
colnames(unassd) <- c('trapVisitID','lifeStage','n.Unassd')
catch.df <- merge(catch.dfA,unassd,by=c('trapVisitID','lifeStage'),all.x=TRUE)
catch.df <- catch.df[order(catch.df$trapPositionID,catch.df$batchDate),]
cat(paste(rep("*",80), collapse=""))
tmp.mess <- paste("Processing ", run.name)
cat(paste("\n", tmp.mess, "\n"))
cat(paste(rep("*",80), collapse=""))
cat("\n\n")
progbar <- winProgressBar( tmp.mess, label="Lifestage X run processing" )
barinc <- 1 / (length(lstages) * 6)
assign( "progbar", progbar, pos=.GlobalEnv )
indRun <- (catch.df$FinalRun == run.name ) & !is.na(catch.df$FinalRun)   # Don't need is.na clause.  FinalRun is never missing here.
#   ---- Loop over lifestages
for( i in 1:length(lstages) ){
ls <- lstages[i]
#   ---- Subset to just one life stage and run
indLS <- (catch.df$lifeStage == ls) & !is.na(catch.df$lifeStage) #  Don't need is.na clause.  I don't think lifeStage can be missing here.
cat(paste("Lifestage=", ls, "; Run=", run.name, "; num records=", sum(indRun & indLS), "\n"))
tmp.mess <- paste("Lifestage=", ls )
setWinProgressBar( progbar, getWinProgressBar(progbar)+barinc, label=tmp.mess )
#   ---- If we caught this run and lifestage, compute passage estimate.
if( any( indRun & indLS ) ){
catch.df.ls <- catch.df[ indRun & indLS, c("trapVisitID", "FinalRun", "lifeStage", 'n.Orig','mean.fl.Orig','sd.fl.Orig',"n.tot", "mean.fl", "sd.fl","n.Unassd")]
#   ---- Merge in the visits to get zeros
catch.df.ls <- merge( visit.df, catch.df.ls, by="trapVisitID", all.x=T )
setWinProgressBar( progbar, getWinProgressBar(progbar)+barinc )
#   ---- Update the constant variables.  Missing n.tot when trap was fishing should be 0.
catch.df.ls$FinalRun[ is.na(catch.df.ls$FinalRun) ] <- run.name
catch.df.ls$lifeStage[ is.na(catch.df.ls$lifeStage) ] <- ls
catch.df.ls$n.tot[ is.na(catch.df.ls$n.tot) & (catch.df.ls$TrapStatus == "Fishing") ] <- 0
catch.df.ls$n.Orig[ is.na(catch.df.ls$n.Orig) & (catch.df.ls$TrapStatus == "Fishing") ] <- 0
catch.df.ls$n.Unassd[ is.na(catch.df.ls$n.Unassd) & (catch.df.ls$TrapStatus == "Fishing") ] <- 0
#   ---- Add back in the missing trapVisitID rows.  These identify the gaps in fishing
#catch.df.ls <- rbind( catch.df.ls, catch.df[ is.na(catch.df$trapVisitID), ] )
#   ---- Update progress bar
out.fn.root <- paste0(output.file, ls, run.name )
setWinProgressBar( progbar, getWinProgressBar(progbar)+barinc )
#   Debugging
#                tmp.c <<- catch.df.ls
#                tmp.r <<- release.df
#   Debugging
#                print(dim(visit.df))
#                print(dim(catch.df.ls))
#                print( table( tmp.c$FinalRun, useNA="always" ))
#                print( table( tmp.c$lifeStage, useNA="always" ))
#                print( table( tmp.c$trapVisitID, useNA="always" ))
#                cat("in lifestage_passage (hit return) ")
#                readline()
#   ---- Compute passage
pass <- F.est.passage( catch.df.ls, release.df, "year", out.fn.root, ci )
#   ---- Update progress bar
setWinProgressBar( progbar, getWinProgressBar(progbar)+barinc )
out.fn.roots <- c(out.fn.roots, attr(pass, "out.fn.list"))
#print(pass)
#   ---- Save
ans[ i, j ] <- pass$passage
lci[ i, j ] <- pass$lower.95
uci[ i, j ] <- pass$upper.95
setWinProgressBar( progbar, getWinProgressBar(progbar)+barinc )
}
}
close(progbar)
}
i
j
pass <- F.est.passage( catch.df.ls, release.df, "year", out.fn.root, ci )
catch.df <- catch.df.ls
release.df <- release.df
summarize.by <- by
file.root <- out.fn.root
ci <- ci
catch.df.sites <- unique(catch.df[,c('trapPositionID','TrapPosition')])                     # jason add
colnames(catch.df.sites) <- c('subSiteID','subSiteName')                                    # jason add
#catch.df$n.Orig <- ifelse(is.na(catch.df$n.Orig) & catch.df$TrapStatus == 'Fishing',0,catch.df$n.Orig)   # jason add -- 4/15/2015 delete 5/20/2015.  do with other 0 overwrite in passage.R
time.zone <- get("time.zone", env=.GlobalEnv )
f.banner <- function( x ){
cat("\n")
cat(paste(rep("=",50), collapse=""));
cat(x);
cat(paste(rep("=",50), collapse=""));
cat("\n")
}
f.banner(" F.est.passage - START ")
#   This keeps track of the files produced
out.fn.list <- NULL
#   retrieve the progress bar
usepb <- exists( "progbar", where=.GlobalEnv )
# jason add: this data frame has the raw unmarked counts of catch.  note that rows with missing data for certain days, i.e., for which imputation
# occurs also appear as line items here.  so, to get catch, for different trapPositionID/subSiteID, summarise and add togeter (b/c some
# days have more than one record).  brings back more dates than ultimately wanted; let merge below (after grand.df) take care of which
# to keep.
jason.catch2.df <- catch.df[,c('trapVisitID','batchDate','trapPositionID','n.Orig')]
jason.catch3.df <- data.frame(with(jason.catch2.df,tapply(n.Orig, list(batchDate,trapPositionID), sum, na.rm=T )))
jason.catch4.df <- na.omit(reshape(jason.catch3.df,idvar='batchDate',ids=row.names(jason.catch3.df),times=names(jason.catch3.df),timevar='trapPositionID',varying=list(names(jason.catch3.df)),direction='long'))
colnames(jason.catch4.df)[2] <- 'rawCatch'
jason.catch4.df$trapPositionID <- as.character(substr(jason.catch4.df$trapPositionID,2,nchar(jason.catch4.df$trapPositionID)))
jason.catch4.df$batchDate <- as.POSIXct(jason.catch4.df$batchDate,time.zone)
# jason 4/15/2015, do the same thing as above, but with n.tot.  sloppy to do this twice like this, but i know the above works.
jason.totCatch2.df <- catch.df[,c('trapVisitID','batchDate','trapPositionID','n.tot')]
jason.totCatch3.df <- data.frame(with(jason.totCatch2.df,tapply(n.tot, list(batchDate,trapPositionID), sum, na.rm=T )))
jason.totCatch4.df <- na.omit(reshape(jason.totCatch3.df,idvar='batchDate',ids=row.names(jason.totCatch3.df),times=names(jason.totCatch3.df),timevar='trapPositionID',varying=list(names(jason.totCatch3.df)),direction='long'))
colnames(jason.totCatch4.df)[2] <- 'inflatedCatch'
jason.totCatch4.df$trapPositionID <- as.character(substr(jason.totCatch4.df$trapPositionID,2,nchar(jason.totCatch4.df$trapPositionID)))
jason.totCatch4.df$batchDate <- as.POSIXct(jason.totCatch4.df$batchDate,time.zone)
#   ------------------------------------------------------------------
#   Estimate capture for every day of season.  Return value is
#   data frame with columns $batchDate and $catch.
#   By default, this produces one graph in a pdf.  Turn this off with plot=F in call.
#       catch.and.fits has components $catch, $fits, $X.miss, $gaps, $bDates.miss, and $trapsOperating
catch.and.fits <- F.est.catch( catch.df, plot=TRUE, plot.file=file.root )
plot.file=file.root
time.zone <- get("time.zone", env=.GlobalEnv )
#   ---- Establish the days on which estimates need to be produced.
#        Times in run season must be same as time in batchDate each day.
#        batchDate must occur at same time every day.  Can be missing days, but always at same time when present.
#start.season <- min(catch.df$batchDate)
#end.season   <- max(catch.df$batchDate)
#   ---- Fill in the gaps for individual traps
df <- NULL
true.imp <- NULL
u.traps <- unique( catch.df$trapPositionID )
catch.fits <- X.miss <- Gaps <- bDates.miss <- vector("list", length(u.traps))   # lists to contain thing to save for bootstrapping
names(catch.fits) <- u.traps
# catch.dff <<- catch.df   # save a copy for debugging
for( trap in u.traps ){
cat(paste("==== Catch model for trapPositionID", trap, "========\n" ))
df2 <- catch.df[catch.df$trapPositionID == trap,]
#   Impute a value for the gaps
#   When df2 comes back from F.catch.model, it has extra lines in it.  One extra line for each 24 hour period in the
#   gaps that were bigger than max.ok.gap. If gap = 3 days, there will be 3 extra lines.
#   sampleStart and sampleEnd for each of the new lines are defined so that no gap appears  now.  Variable
#   'gamEstimated' is true for these periods. Batch date is assigned based on sampleEnd, as usual.
#   On return, there is a value or imputed value for each day from start of season to end of season.
df.and.fit <- suppressWarnings( F.catch.model( df2 ) )  # df.and.fit is list of, $df2 contains data frame, $fit contains model, etc
#jason.df.and.fit <<- df.and.fit
df <- rbind( df, df.and.fit$df2)
catch.fits[[which(trap==u.traps)]] <- df.and.fit$fit
X.miss[[which(trap==u.traps)]] <- df.and.fit$X.for.missings
Gaps[[which(trap==u.traps)]] <- df.and.fit$gaps
bDates.miss[[which(trap==u.traps)]] <- df.and.fit$batchDate.for.missings
true.imp <- rbind(true.imp,df.and.fit$true.imp)
#    print(df.and.fit)
#    cat("in est_catch (hit return):")
#    readline()
}
# true.imp <<- true.imp
cat("in est_catch.r  DF")
print( tapply(df$batchDate, df$trapPositionID, range) )
cat("-------\n")
u.traps
trap
cat(paste("==== Catch model for trapPositionID", trap, "========\n" ))
df2 <- catch.df[catch.df$trapPositionID == trap,]
#   Impute a value for the gaps
#   When df2 comes back from F.catch.model, it has extra lines in it.  One extra line for each 24 hour period in the
#   gaps that were bigger than max.ok.gap. If gap = 3 days, there will be 3 extra lines.
#   sampleStart and sampleEnd for each of the new lines are defined so that no gap appears  now.  Variable
#   'gamEstimated' is true for these periods. Batch date is assigned based on sampleEnd, as usual.
#   On return, there is a value or imputed value for each day from start of season to end of season.
df2
catch.df <- df2
#   Sort the data frame properly, by trapPosition and date of visit
#   This puts the gaps in their correct locations
catch.df <- catch.df[ order(catch.df$trapPositionID, catch.df$EndTime), ]
#   Compute the "night" variables.
time.zone <- get("time.zone", env=.GlobalEnv )
sunset  <- as.POSIXct( paste(format(catch.df$StartTime, "%Y-%m-%d"), "19:00:00"), format="%Y-%m-%d %H:%M:%S", tzone=time.zone )
sunrise <- as.POSIXct( paste(format(catch.df$EndTime, "%Y-%m-%d"), "07:00:00"), format="%Y-%m-%d %H:%M:%S", tzone=time.zone )
catch.df$night <- 0
catch.df$pct.night <- 0
ind <- (catch.df$StartTime <= sunset) & (sunrise <= catch.df$EndTime)
catch.df$night[ind] <- 1
catch.df$pct.night[ind] <- 1
ind <- (catch.df$StartTime <= sunset) & (sunrise > catch.df$EndTime)
catch.df$night[ind] <- 1
catch.df$pct.night[ind] <- (as.numeric(catch.df$EndTime[ind]) - as.numeric(sunset[ind])) / (as.numeric(sunrise[ind]) - as.numeric(sunset[ind]))
ind <- (catch.df$sampleStart > sunset) & (sunrise <= catch.df$EndTime)
catch.df$night[ind] <- 1
catch.df$pct.night[ind] <- (as.numeric(sunrise[ind]) - as.numeric(catch.df$StartTime[ind])) / (as.numeric(sunrise[ind]) - as.numeric(sunset[ind]))
#   Fit a rate model.
library(splines)
#catch.df <- catch.df[ catch.df$TrapStatus == "Fishing", ]
catch.df$log.sampleLengthHrs <- log(as.numeric( catch.df$SampleMinutes/60 ))
p.night <- sum(catch.df$night) / nrow(catch.df)
#   Fit null model.  The gap catches are NA here, so they are dropped from the fit.  Later, they are replaced.
if( p.night < 0.9 ){
fit <- glm( n.tot ~ offset(log.sampleLengthHrs)  + night, family=poisson, data=catch.df )
} else {
fit <- glm( n.tot ~ offset(log.sampleLengthHrs) , family=poisson, data=catch.df )
}
fit.AIC <- AIC(fit)
#tmp.cc <<- catch.df   # print( tmp.cc[,c(1,3,4,5,6,7,10,18)] )
#   Fit glm model, increasing df, until the model goes bad
cat(paste("Number of non-zero catches : ", sum(!is.na(catch.df$n.tot) & (catch.df$n.tot > 0)), "\n"))
cat("Catch model fitting:\n")
cat(paste("df= ", 0, ", conv= ", fit$converged, " bound= ", fit$boundary, " AIC= ", round(fit.AIC, 4), "\n"))
fit
summary(fit)
if( sum(!is.na(catch.df$n.tot) & (catch.df$n.tot > 0)) > 10 ){
cur.df <- 1  # this is df in smoother part, excluding intercept.  1=linear, 2=quadratic, 3=bspline w/ 1 internal knot, 4=bspline w/ 2 internal knots, etc.
repeat{
if( cur.df == 1 ){
j <- as.numeric( format(catch.df$EndTime, "%j"))
bs.sEnd <- matrix(j,ncol=1)
} else if( cur.df == 2 ){
j <- as.numeric( format(catch.df$EndTime, "%j"))
bs.sEnd <- cbind(Lin=j, Quad=j*j)
} else {
bs.sEnd <- bs( catch.df$EndTime, df=cur.df )
}
if( p.night < 0.9 ){
cur.fit <- glm( n.tot ~ offset(log.sampleLengthHrs) + bs.sEnd + night, family=poisson, data=catch.df )
} else {
cur.fit <- glm( n.tot ~ offset(log.sampleLengthHrs) + bs.sEnd, family=poisson, data=catch.df )
}
cur.AIC <- AIC( cur.fit )
cat(paste("df= ", cur.df, ", conv= ", cur.fit$converged, " bound= ", cur.fit$boundary, " AIC= ", round(cur.AIC, 4), "\n"))
if( !cur.fit$converged | cur.fit$boundary | cur.df > 15 | cur.AIC > (fit.AIC - 2) ){
break
} else {
fit <- cur.fit
fit.AIC <- cur.AIC
bs.sampleEnd <- bs.sEnd
cur.df <- cur.df + 1
}
}
}
sum(!is.na(catch.df$n.tot) & (catch.df$n.tot > 0)) > 10
n.tot
catch.df
catch.df[as.Date(catch.df$batchDate) == '2009-11-01',]
head(catch.df)
head(catch.df,20)
catch.df[as.Date(catch.df$batchDate) == '2009-11-08',]
testi
testi
theExcel
# specify the range, in terms of theExcel rownames, to test.
for(testi in 33:65){
for(byj in 1:4){
if(byj == 1){
by <- 'day'
} else if(byj == 2){
by <- 'week'
} else if(byj == 3){
by <- 'month'
} else if(byj == 4){
by <- 'year'
}
river <- as.character(droplevels(theExcel[testi,]$streamName))
if(river == ''){
db.file <- db.file1
} else if(river == 'Sacramento River'){
db.file <- db.file2
} else if(river == 'American River'){
db.file <- db.file3
} else if(river == ''){
db.file <- db.file4
} else if(river == 'Feather River'){
db.file <- db.file5
} else if(river == 'Stanislaus River'){
db.file <- db.file6
} else if(river == 'Old American Test'){
db.file <- db.file7
} else if(river == 'Mokelumne River'){
db.file <- db.file8
}
if(river != 'Old American Test'){
site         <- theExcel[testi,]$siteID
siteText     <- as.character(droplevels(theExcel[testi,]$Site))
run          <- theExcel[testi,]$RunID
runText      <- as.character(droplevels(theExcel[testi,]$SalmonRun))
min.date     <- as.character(as.Date(theExcel[testi,]$minvisitTime,format = "%m/%d/%Y"))
max.date     <- as.character(as.Date(theExcel[testi,]$maxvisitTime,format = "%m/%d/%Y"))
} else {
river        <- 'american'
site         <- 57000
siteText     <- 'testing'
run          <- 4
runText      <- 'Winter'
min.date     <- "2013-10-01"
max.date     <- "2014-09-29"
}
taxon        <- 161980
output.file  <- paste0("..//Outputs//",river,"//",by,"_",river,"_",siteText,"_",min.date,"_",max.date)
ci           <- TRUE
output.type  <- "odt"
from         <- "Trent McDonald, Ph.D., WEST Incorporated"
to           <- "Doug Threloff, USFWS CAMP Coordinator"
return.addr  <- "FISH AND WILDLIFE SERVICE!USFWS Caswell State Park Office!1234 Abbey Rd.!Caswell, California  96080!(530) 527-3043, FAX (530) 529-0292"
#     F.passage       ( site, taxon, run, min.date, max.date, by,        output.file,                ci                      )
#   }
#      F.release.summary ( site, taxon, run, min.date, max.date,            output.file                                         )
#     F.size.by.date    ( site, taxon, run, min.date, max.date,            output.file                                         )
#      F.length.frequency( site, taxon, run, min.date, max.date,     paste0(output.file,"_lifestage=T"),   by.lifestage=FALSE   )
#      F.length.frequency( site, taxon, run, min.date, max.date,     paste0(output.file,"_lifestage=F"),   by.lifestage=TRUE    )
#      F.weekly.effort   ( site, taxon,      min.date, max.date,            output.file                                         )
F.run.passage     ( site, taxon,      min.date, max.date, by=by,     output.file=output.file,         ci=TRUE            )
F.lifestage.passage(site, taxon,      min.date, max.date,            output.file,                     ci=TRUE            )
}
}
testi
theExcel
grand.df
# specify the range, in terms of theExcel rownames, to test.
for(testi in 41:65){
for(byj in 1:4){
if(byj == 1){
by <- 'day'
} else if(byj == 2){
by <- 'week'
} else if(byj == 3){
by <- 'month'
} else if(byj == 4){
by <- 'year'
}
river <- as.character(droplevels(theExcel[testi,]$streamName))
if(river == ''){
db.file <- db.file1
} else if(river == 'Sacramento River'){
db.file <- db.file2
} else if(river == 'American River'){
db.file <- db.file3
} else if(river == ''){
db.file <- db.file4
} else if(river == 'Feather River'){
db.file <- db.file5
} else if(river == 'Stanislaus River'){
db.file <- db.file6
} else if(river == 'Old American Test'){
db.file <- db.file7
} else if(river == 'Mokelumne River'){
db.file <- db.file8
}
if(river != 'Old American Test'){
site         <- theExcel[testi,]$siteID
siteText     <- as.character(droplevels(theExcel[testi,]$Site))
run          <- theExcel[testi,]$RunID
runText      <- as.character(droplevels(theExcel[testi,]$SalmonRun))
min.date     <- as.character(as.Date(theExcel[testi,]$minvisitTime,format = "%m/%d/%Y"))
max.date     <- as.character(as.Date(theExcel[testi,]$maxvisitTime,format = "%m/%d/%Y"))
} else {
river        <- 'american'
site         <- 57000
siteText     <- 'testing'
run          <- 4
runText      <- 'Winter'
min.date     <- "2013-10-01"
max.date     <- "2014-09-29"
}
taxon        <- 161980
output.file  <- paste0("..//Outputs//",river,"//",by,"_",river,"_",siteText,"_",min.date,"_",max.date)
ci           <- TRUE
output.type  <- "odt"
from         <- "Trent McDonald, Ph.D., WEST Incorporated"
to           <- "Doug Threloff, USFWS CAMP Coordinator"
return.addr  <- "FISH AND WILDLIFE SERVICE!USFWS Caswell State Park Office!1234 Abbey Rd.!Caswell, California  96080!(530) 527-3043, FAX (530) 529-0292"
#     F.passage       ( site, taxon, run, min.date, max.date, by,        output.file,                ci                      )
#   }
#      F.release.summary ( site, taxon, run, min.date, max.date,            output.file                                         )
#     F.size.by.date    ( site, taxon, run, min.date, max.date,            output.file                                         )
#      F.length.frequency( site, taxon, run, min.date, max.date,     paste0(output.file,"_lifestage=T"),   by.lifestage=FALSE   )
#      F.length.frequency( site, taxon, run, min.date, max.date,     paste0(output.file,"_lifestage=F"),   by.lifestage=TRUE    )
#      F.weekly.effort   ( site, taxon,      min.date, max.date,            output.file                                         )
F.run.passage     ( site, taxon,      min.date, max.date, by=by,     output.file=output.file,         ci=TRUE            )
F.lifestage.passage(site, taxon,      min.date, max.date,            output.file,                     ci=TRUE            )
}
}
testi
theExcel
testi <- 42
# specify the range, in terms of theExcel rownames, to test.
for(testi in 41:65){
for(byj in 1:4){
if(byj == 1){
by <- 'day'
} else if(byj == 2){
by <- 'week'
} else if(byj == 3){
by <- 'month'
} else if(byj == 4){
by <- 'year'
}
river <- as.character(droplevels(theExcel[testi,]$streamName))
if(river == ''){
db.file <- db.file1
} else if(river == 'Sacramento River'){
db.file <- db.file2
} else if(river == 'American River'){
db.file <- db.file3
} else if(river == ''){
db.file <- db.file4
} else if(river == 'Feather River'){
db.file <- db.file5
} else if(river == 'Stanislaus River'){
db.file <- db.file6
} else if(river == 'Old American Test'){
db.file <- db.file7
} else if(river == 'Mokelumne River'){
db.file <- db.file8
}
if(river != 'Old American Test'){
site         <- theExcel[testi,]$siteID
siteText     <- as.character(droplevels(theExcel[testi,]$Site))
run          <- theExcel[testi,]$RunID
runText      <- as.character(droplevels(theExcel[testi,]$SalmonRun))
min.date     <- as.character(as.Date(theExcel[testi,]$minvisitTime,format = "%m/%d/%Y"))
max.date     <- as.character(as.Date(theExcel[testi,]$maxvisitTime,format = "%m/%d/%Y"))
} else {
river        <- 'american'
site         <- 57000
siteText     <- 'testing'
run          <- 4
runText      <- 'Winter'
min.date     <- "2013-10-01"
max.date     <- "2014-09-29"
}
taxon        <- 161980
output.file  <- paste0("..//Outputs//",river,"//",by,"_",river,"_",siteText,"_",min.date,"_",max.date)
ci           <- TRUE
output.type  <- "odt"
from         <- "Trent McDonald, Ph.D., WEST Incorporated"
to           <- "Doug Threloff, USFWS CAMP Coordinator"
return.addr  <- "FISH AND WILDLIFE SERVICE!USFWS Caswell State Park Office!1234 Abbey Rd.!Caswell, California  96080!(530) 527-3043, FAX (530) 529-0292"
#     F.passage       ( site, taxon, run, min.date, max.date, by,        output.file,                ci                      )
#   }
#      F.release.summary ( site, taxon, run, min.date, max.date,            output.file                                         )
#     F.size.by.date    ( site, taxon, run, min.date, max.date,            output.file                                         )
#      F.length.frequency( site, taxon, run, min.date, max.date,     paste0(output.file,"_lifestage=T"),   by.lifestage=FALSE   )
#      F.length.frequency( site, taxon, run, min.date, max.date,     paste0(output.file,"_lifestage=F"),   by.lifestage=TRUE    )
#      F.weekly.effort   ( site, taxon,      min.date, max.date,            output.file                                         )
F.run.passage     ( site, taxon,      min.date, max.date, by=by,     output.file=output.file,         ci=TRUE            )
F.lifestage.passage(site, taxon,      min.date, max.date,            output.file,                     ci=TRUE            )
}
}
testi
# specify the range, in terms of theExcel rownames, to test.
for(testi in 42:65){
for(byj in 1:4){
if(byj == 1){
by <- 'day'
} else if(byj == 2){
by <- 'week'
} else if(byj == 3){
by <- 'month'
} else if(byj == 4){
by <- 'year'
}
river <- as.character(droplevels(theExcel[testi,]$streamName))
if(river == ''){
db.file <- db.file1
} else if(river == 'Sacramento River'){
db.file <- db.file2
} else if(river == 'American River'){
db.file <- db.file3
} else if(river == ''){
db.file <- db.file4
} else if(river == 'Feather River'){
db.file <- db.file5
} else if(river == 'Stanislaus River'){
db.file <- db.file6
} else if(river == 'Old American Test'){
db.file <- db.file7
} else if(river == 'Mokelumne River'){
db.file <- db.file8
}
if(river != 'Old American Test'){
site         <- theExcel[testi,]$siteID
siteText     <- as.character(droplevels(theExcel[testi,]$Site))
run          <- theExcel[testi,]$RunID
runText      <- as.character(droplevels(theExcel[testi,]$SalmonRun))
min.date     <- as.character(as.Date(theExcel[testi,]$minvisitTime,format = "%m/%d/%Y"))
max.date     <- as.character(as.Date(theExcel[testi,]$maxvisitTime,format = "%m/%d/%Y"))
} else {
river        <- 'american'
site         <- 57000
siteText     <- 'testing'
run          <- 4
runText      <- 'Winter'
min.date     <- "2013-10-01"
max.date     <- "2014-09-29"
}
taxon        <- 161980
output.file  <- paste0("..//Outputs//",river,"//",by,"_",river,"_",siteText,"_",min.date,"_",max.date)
ci           <- TRUE
output.type  <- "odt"
from         <- "Trent McDonald, Ph.D., WEST Incorporated"
to           <- "Doug Threloff, USFWS CAMP Coordinator"
return.addr  <- "FISH AND WILDLIFE SERVICE!USFWS Caswell State Park Office!1234 Abbey Rd.!Caswell, California  96080!(530) 527-3043, FAX (530) 529-0292"
#     F.passage       ( site, taxon, run, min.date, max.date, by,        output.file,                ci                      )
#   }
#      F.release.summary ( site, taxon, run, min.date, max.date,            output.file                                         )
#     F.size.by.date    ( site, taxon, run, min.date, max.date,            output.file                                         )
#      F.length.frequency( site, taxon, run, min.date, max.date,     paste0(output.file,"_lifestage=T"),   by.lifestage=FALSE   )
#      F.length.frequency( site, taxon, run, min.date, max.date,     paste0(output.file,"_lifestage=F"),   by.lifestage=TRUE    )
#      F.weekly.effort   ( site, taxon,      min.date, max.date,            output.file                                         )
F.run.passage     ( site, taxon,      min.date, max.date, by=by,     output.file=output.file,         ci=TRUE            )
F.lifestage.passage(site, taxon,      min.date, max.date,            output.file,                     ci=TRUE            )
}
}
