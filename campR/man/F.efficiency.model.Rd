% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eff_model.r
\name{F.efficiency.model}
\alias{F.efficiency.model}
\title{F.efficiency.model}
\usage{
F.efficiency.model(obs.eff.df, plot = T, method = 1, max.df.spline = 4,
  plot.file = NA)
}
\arguments{
\item{obs.eff.df}{<describe argument>}

\item{plot=T}{<describe argument>}

\item{method=1}{<describe argument>}

\item{max.df.spline=4}{<describe argument>}

\item{plot.file=NA}{<describe argument>}
}
\value{
<describe return value>
}
\description{
Compute and estimate efficiency for all traps and days that are missing in the input data set.
   i.e., "impute" a value for efficiency when it is missing

   input:
   obs.eff.df = data frame with at least columns $batchDate, and $efficiency.
       $efficiency is NA for all days that we need an estimate.  
   method = scalar specifying type of extrapolation to do.  Method = 1 takes average of entire season. 
       Method = 2 uses earliest observed efficiency between in intervals between efficiency trials (so called
       constant model).  Method = 3 is a b-spline model with up to 'max.df.spline' degrees of freedom.
   max.df.spling = maximum degrees of freedom for splines

   Output:
   A data frame with all observed $efficiency values, plus a the column $gam.estimated 
   which is 1 = "Yes" for those that came from the model. 


 obs.eff.df=eff
 plot=T
 method=1
 max.df.spline=4
 plot.file=NA
   It is possible to implement a GAM here using covariates like flow, time of day
   check was done, etc. and a smooting component.  For now, I will only implement a
   simple step function
   obs.eff.df <- eff 
   plot <- plot
   method <- method
   max.df.spline <- df.spline
}
\details{
<other comments found in file>
readline()
   Season mean model
   If want to use ROM for missing efficiencies only, uncomment the next line
df$efficiency[!ind] <- obs.mean
   If, however, you want to use ROM for all days, missing or not, uncomment the next line
   WARNING: method 2 is not fully programmed to be compatible with bootstrapping.  Don't use unless you program the bootstrapping to accept it.
   Fit glm model, increasing df, until something goes wrong
   Check that there are adequate trials at this trap
   No efficiency trials at this trap
   Go with the mean model
   If you want to use observed efficiency on days when efficiency trials were turn, uncomment the following 
   three lines.  
miss.eff.inside <- ind.inside & !ind  # missing efficiencies inside first and last trials, sized same as df
miss.eff <- miss.eff.inside[ind.inside]      # missing efficiencies inside first and last trials, sized same as pred
df$efficiency[miss.eff.inside] <- pred[miss.eff]
   If, however, you want to use the modeled efficiency for all days, even when a trial was done, use these 
   lines.  
print( c(sum(miss.eff.inside), sum(miss.eff)) )
print( c(length(miss.eff.inside), length(miss.eff)) )
   use the mean of spline estimate for all dates outside efficiency trial season
   Uncomment the following line if using imputed value for all days.  Otherwise, comment it out, and imputed.eff will tell which are observed.
   With the following uncommented, you can find efficiency trials in grand.df with !is.na(grand.df$nReleased)
   Make a plot if called for
}
\examples{
<insert examples>

}
\author{
WEST Inc.
}
\seealso{
\code{\link{<related routine>}}, \code{\link{<related routine>}}
}

